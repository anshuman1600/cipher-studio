# üéØ Major Design Decisions - CipherStudio

This document explains the key architectural and technical decisions made during the development of CipherStudio.

---

## üìã Table of Contents

1. [Frontend Architecture](#1-frontend-architecture)
2. [Code Editor Choice](#2-code-editor-choice)
3. [Live Preview Implementation](#3-live-preview-implementation)
4. [Authentication Strategy](#4-authentication-strategy)
5. [Data Storage Strategy](#5-data-storage-strategy)
6. [File Structure Design](#6-file-structure-design)
7. [State Management](#7-state-management)
8. [API Design](#8-api-design)

---

## 1. Frontend Architecture

### **Decision: React with Vite**

#### Why React?
- ‚úÖ Component-based architecture (reusable UI elements)
- ‚úÖ Large ecosystem (Monaco, Sandpack integrate easily)
- ‚úÖ Virtual DOM for efficient updates
- ‚úÖ Industry standard (familiar to developers)

#### Why Vite over Create React App?
- ‚úÖ **Faster dev server** (instant HMR)
- ‚úÖ **Smaller bundle size** (ES modules)
- ‚úÖ **Modern tooling** (esbuild for blazing fast builds)
- ‚úÖ **Better DX** (out-of-the-box support for JSX, CSS)

#### Alternatives Considered:
| Framework | Pros | Cons | Verdict |
|-----------|------|------|---------|
| **Vue.js** | Simpler learning curve | Smaller ecosystem for dev tools | ‚ùå Less Monaco/Sandpack support |
| **Angular** | Full-featured framework | Too heavy for our use case | ‚ùå Overkill for MVP |
| **Svelte** | No virtual DOM overhead | Smaller community | ‚ùå Fewer IDE libraries |

**Final Choice:** React + Vite ‚úÖ

---

## 2. Code Editor Choice

### **Decision: Monaco Editor**

#### Why Monaco?
- ‚úÖ **Powers VS Code** (industry-standard editor)
- ‚úÖ **Rich features out-of-the-box:**
  - Syntax highlighting
  - IntelliSense autocomplete
  - Multi-cursor editing
  - Find & replace
  - Code folding
- ‚úÖ **Multi-language support** (JS, HTML, CSS, Python, etc.)
- ‚úÖ **TypeScript definitions** (great DX)
- ‚úÖ **Customizable themes** (VS Dark, Light, High Contrast)

#### Alternatives Considered:
| Editor | Pros | Cons | Verdict |
|--------|------|------|---------|
| **CodeMirror** | Lightweight, modular | Less feature-rich | ‚ùå More setup required |
| **Ace Editor** | Mature, stable | Older API design | ‚ùå Less modern |
| **Plain Textarea** | Simple | No features | ‚ùå Poor UX |

#### Trade-offs:
- **Bundle Size:** Monaco adds ~2MB to bundle
  - **Mitigation:** Lazy load Monaco, code splitting
- **Load Time:** Slight initial delay
  - **Acceptable:** Professional IDE experience is worth it

**Final Choice:** Monaco Editor ‚úÖ

---

## 3. Live Preview Implementation

### **Decision: Sandpack (CodeSandbox)**

#### Why Sandpack?
- ‚úÖ **Real-time bundling** (Webpack in browser)
- ‚úÖ **Isolated sandbox** (secure iframe execution)
- ‚úÖ **React support** (JSX transpilation)
- ‚úÖ **No backend needed** (client-side compilation)
- ‚úÖ **Maintained by CodeSandbox** (proven reliability)
- ‚úÖ **Hot reload** (instant preview updates)

#### Alternatives Considered:
| Solution | Pros | Cons | Verdict |
|----------|------|------|---------|
| **Custom Bundler** | Full control | Complex to build | ‚ùå Time-consuming |
| **iframe + eval** | Simple | Security risks, no JSX | ‚ùå Unsafe |
| **Backend compilation** | More powerful | Requires server, slower | ‚ùå Adds complexity |
| **StackBlitz WebContainers** | Full Node.js | Limited browser support | ‚ùå Compatibility issues |

#### Implementation Details:
```jsx
<Sandpack
  key={filesKey} // Force remount on file change
  template="react"
  files={sandpackFiles}
  options={{
    showNavigator: true,
    layout: 'preview',
    editorWidthPercentage: 0, // Hide Sandpack editor
  }}
/>
```

**Key Innovation:** Use `filesKey` to force Sandpack remount when files change, ensuring preview updates immediately.

**Final Choice:** Sandpack ‚úÖ

---

## 4. Authentication Strategy

### **Decision: JWT (JSON Web Tokens)**

#### Why JWT?
- ‚úÖ **Stateless** (no server-side session storage)
- ‚úÖ **Scalable** (works across multiple servers)
- ‚úÖ **Standard** (industry best practice for SPAs)
- ‚úÖ **Mobile-friendly** (works in mobile apps)
- ‚úÖ **Self-contained** (userId embedded in token)

#### Implementation:
```javascript
// Login flow
const token = jwt.sign({ userId: user._id }, JWT_SECRET, { expiresIn: '30d' });

// Authentication middleware
const decoded = jwt.verify(token, JWT_SECRET);
req.user = await User.findById(decoded.userId);
```

#### Alternatives Considered:
| Method | Pros | Cons | Verdict |
|--------|------|------|---------|
| **Sessions + Cookies** | Can invalidate immediately | Requires server storage | ‚ùå Not scalable |
| **OAuth 2.0** | Industry standard | Complex setup | ‚ùå Overkill for MVP |
| **API Keys** | Simple | Less secure | ‚ùå No user context |

#### Security Measures:
- ‚úÖ **Password hashing:** bcrypt with 10 salt rounds
- ‚úÖ **Token expiration:** 30 days
- ‚úÖ **HTTPS only** (in production)
- ‚ö†Ô∏è **TODO:** Implement refresh tokens
- ‚ö†Ô∏è **TODO:** Use httpOnly cookies (more secure than localStorage)

**Final Choice:** JWT Authentication ‚úÖ

---

## 5. Data Storage Strategy

### **Decision: Hybrid Approach (localStorage + MongoDB)**

#### Why Hybrid?
- ‚úÖ **Best of both worlds:**
  - localStorage: Instant saves, offline access
  - MongoDB: Persistence, cross-device sync

#### localStorage (Local Saves)
**Use Case:** Quick saves, work-in-progress

**Advantages:**
- Instant write (no network latency)
- Works offline
- No database load
- No login required

**Limitations:**
- 5-10MB storage limit
- Not synced across devices
- Cleared if user clears browser data

**Data Structure:**
```javascript
{
  name: "my-react-app",
  files: { /* hierarchical structure */ },
  activeFile: "App.js",
  projectId: "68f5bd5a...", // Link to cloud (if loaded)
  savedAt: "2025-10-20T10:30:00.000Z"
}
```

#### MongoDB (Cloud Saves)
**Use Case:** Persistence, sharing, backup

**Advantages:**
- 16MB document size (plenty for code)
- Cross-device sync
- User authentication
- Backup & recovery

**Limitations:**
- Requires network
- Requires login
- Database costs

**Data Structure:**
```javascript
{
  _id: ObjectId,
  userId: ObjectId, // User ownership
  name: String,
  files: Object, // Same format as localStorage
  activeFile: String,
  createdAt: Date,
  updatedAt: Date
}
```

#### Smart Save/Update Logic:
```javascript
if (currentProjectId) {
  // Update existing cloud project
  await updateProject(currentProjectId, projectData);
} else {
  // Create new cloud project
  const result = await saveProject(projectData);
  setCurrentProjectId(result.project._id); // Link to cloud
}
```

**Key Innovation:** `currentProjectId` acts as a "link" between local and cloud project.

**Final Choice:** Hybrid Storage ‚úÖ

---

## 6. File Structure Design

### **Decision: Hierarchical Object Structure**

#### Why Hierarchical?
- ‚úÖ **Natural representation** (folders contain children)
- ‚úÖ **Easier navigation** (tree traversal)
- ‚úÖ **Simpler queries** (no joins needed)
- ‚úÖ **Familiar to developers** (matches file system)

#### Data Structure:
```javascript
{
  'App.js': {
    type: 'file',
    code: 'export default function App() { ... }'
  },
  'components': {
    type: 'folder',
    children: {
      'Button.js': {
        type: 'file',
        code: 'export default function Button() { ... }'
      }
    }
  }
}
```

#### Alternatives Considered:
| Structure | Pros | Cons | Verdict |
|-----------|------|------|---------|
| **Flat Array** | Simple to query | Complex path resolution | ‚ùå Harder to navigate |
| **Path-based** | Efficient for deep trees | Requires parsing | ‚ùå More complex |
| **Graph Database** | Flexible relationships | Overkill | ‚ùå Too complex |

#### Limitations & Solutions:
**Problem:** MongoDB 16MB document size limit

**Solution:** Dual approach:
1. **Small projects:** Use hierarchical structure (fast, simple)
2. **Large projects:** Migrate to separate Files collection

#### Files Collection (S3-Ready):
```javascript
{
  _id: ObjectId,
  projectId: ObjectId,
  parentId: ObjectId, // null for root files
  name: String,
  type: 'file' | 'folder',
  content: String, // or s3Key for large files
  path: String, // '/components/Button.js'
  size: Number,
  createdAt: Date
}
```

**Future-Proofing:** Files collection ready for AWS S3 migration.

**Final Choice:** Hierarchical + Files Collection ‚úÖ

---

## 7. State Management

### **Decision: React useState (No Redux)**

#### Why No Redux?
- ‚úÖ **Simple state needs** (files, user, projectId)
- ‚úÖ **Component-local state** (no complex global state)
- ‚úÖ **Fewer dependencies** (smaller bundle)
- ‚úÖ **Faster development** (less boilerplate)

#### State Structure:
```javascript
// App.jsx
const [files, setFiles] = useState(STARTER_TEMPLATE);
const [activeFile, setActiveFile] = useState('App.js');
const [projectName, setProjectName] = useState('my-react-app');
const [currentProjectId, setCurrentProjectId] = useState(null);
const [user, setUser] = useState(null);
const [theme, setTheme] = useState('dark');
```

#### Prop Drilling:
**Problem:** Passing props through multiple levels

**Solution:** Direct prop passing (acceptable for small app)
```jsx
<Toolbar
  projectName={projectName}
  user={user}
  onSave={handleSave}
  onLogin={() => setShowAuthModal(true)}
/>
```

#### When to Add Redux?
**Indicators:**
- More than 5 levels of prop drilling
- Shared state across many components
- Complex state updates (async actions)

**Current Status:** Not needed yet ‚úÖ

**Final Choice:** React useState ‚úÖ

---

## 8. API Design

### **Decision: RESTful JSON API**

#### Why REST?
- ‚úÖ **Simple & standard** (HTTP methods: GET, POST, PUT, DELETE)
- ‚úÖ **Stateless** (each request independent)
- ‚úÖ **Cacheable** (HTTP caching)
- ‚úÖ **Well-documented** (OpenAPI/Swagger support)

#### Endpoint Structure:
```
Authentication:
POST   /api/auth/register      Create new user
POST   /api/auth/login         Login user
GET    /api/auth/me            Get current user

Projects:
GET    /api/projects           List user's projects
POST   /api/projects           Create new project
GET    /api/projects/:id       Get project by ID
PUT    /api/projects/:id       Update project
DELETE /api/projects/:id       Delete project

Files:
GET    /api/files/:id          Get file by ID
POST   /api/files              Create file
PUT    /api/files/:id          Update file
DELETE /api/files/:id          Delete file
```

#### Response Format:
**Success:**
```json
{
  "success": true,
  "data": { /* response data */ },
  "message": "Operation successful"
}
```

**Error:**
```json
{
  "success": false,
  "error": "Error message",
  "statusCode": 404
}
```

#### Alternatives Considered:
| API Type | Pros | Cons | Verdict |
|----------|------|------|---------|
| **GraphQL** | Flexible queries | Complex setup | ‚ùå Overkill |
| **gRPC** | High performance | Binary protocol, harder to debug | ‚ùå Too complex |
| **WebSocket** | Real-time updates | Harder to scale | ‚ùå Not needed yet |

#### Authorization Pattern:
```javascript
// Middleware: Extract userId from JWT
const userId = req.user._id;

// Controller: Filter by userId
const projects = await Project.find({ userId });
```

**Key Security:** Never trust client-sent `userId`, always extract from JWT token.

**Final Choice:** RESTful API ‚úÖ

---

## üîÑ Evolution Path

### **Phase 1: MVP (Current)**
- ‚úÖ Basic CRUD operations
- ‚úÖ User authentication
- ‚úÖ Local + Cloud saves
- ‚úÖ Live preview

### **Phase 2: Enhanced Features**
- üî≤ File versioning (Git-like)
- üî≤ Project templates
- üî≤ Keyboard shortcuts
- üî≤ Multi-file search

### **Phase 3: Collaboration**
- üî≤ WebSocket real-time editing
- üî≤ User presence indicators
- üî≤ Comments & annotations
- üî≤ Share project links

### **Phase 4: Scale**
- üî≤ S3 file storage
- üî≤ Redis caching
- üî≤ Load balancing
- üî≤ CDN integration

---

## üìä Decision Matrix

| Feature | Complexity | Impact | Priority | Status |
|---------|------------|--------|----------|--------|
| Monaco Editor | Medium | High | P0 | ‚úÖ Done |
| Sandpack Preview | Medium | High | P0 | ‚úÖ Done |
| JWT Auth | Low | High | P0 | ‚úÖ Done |
| Hybrid Storage | Low | High | P0 | ‚úÖ Done |
| Files Collection | Medium | Medium | P1 | ‚úÖ Done |
| WebSocket Collab | High | High | P2 | üî≤ Future |
| S3 Storage | Medium | Medium | P2 | üî≤ Future |
| Git Integration | High | Medium | P3 | üî≤ Future |

---

## üí° Lessons Learned

### **What Went Well:**
1. ‚úÖ Monaco + Sandpack integration smooth
2. ‚úÖ Hierarchical file structure works great
3. ‚úÖ JWT auth simple yet secure
4. ‚úÖ Hybrid storage provides flexibility

### **What Could Be Improved:**
1. ‚ö†Ô∏è Consider Context API for state management as app grows
2. ‚ö†Ô∏è Implement httpOnly cookies for tokens (more secure)
3. ‚ö†Ô∏è Add API rate limiting earlier
4. ‚ö†Ô∏è Set up CI/CD from start

### **Future Considerations:**
1. üîÆ WebSocket for real-time collaboration
2. üîÆ Redis for session/cache management
3. üîÆ GraphQL for flexible queries
4. üîÆ TypeScript for type safety

---

## üéì Key Takeaways

### **For Developers:**
- **Start simple:** MVP first, optimize later
- **Use proven tools:** Monaco, Sandpack, JWT (don't reinvent)
- **Security first:** Hash passwords, verify tokens, filter by userId
- **Plan for scale:** Files collection ready for S3

### **For Architects:**
- **Separation of concerns:** Client, Server, Database clearly separated
- **Flexibility:** Hybrid storage allows online/offline use
- **Extensibility:** Modular design easy to extend
- **Documentation:** Decisions documented for future team

---

**Last Updated:** October 20, 2025  
**Version:** 1.0.0  
**Author:** CipherStudio Team
